import{_ as e,c as a,o as t,a6 as r}from"./chunks/framework.DJ4Mgv9l.js";const k=JSON.parse('{"title":"Representation of data","description":"","frontmatter":{},"headers":[],"relativePath":"guide/types.md","filePath":"guide/types.md","lastUpdated":null}'),o={name:"guide/types.md"},s=r('<h1 id="Representation-of-data" tabindex="-1">Representation of data <a class="header-anchor" href="#Representation-of-data" aria-label="Permalink to &quot;Representation of data {#Representation-of-data}&quot;">​</a></h1><p>Entire experiments are represented using one of two structs. Each with an associated struct for representing a single cluster/cell within an experiment:</p><ul><li><p><a href="/Laska.jl/dev/ref/core_ref#LaskaCore.PhyOutput"><code>LaskaCore.PhyOutput</code></a> containing <a href="/Laska.jl/dev/ref/core_ref#LaskaCore.Cluster"><code>LaskaCore.Cluster</code></a></p></li><li><p><a href="/Laska.jl/dev/ref/core_ref#LaskaCore.RelativeSpikes"><code>LaskaCore.RelativeSpikes</code></a> containing <a href="/Laska.jl/dev/ref/core_ref#LaskaCore.RelativeCluster"><code>LaskaCore.RelativeCluster</code></a></p></li></ul><h2 id="phyoutput" tabindex="-1">PhyOutput <a class="header-anchor" href="#phyoutput" aria-label="Permalink to &quot;PhyOutput&quot;">​</a></h2><p>A <code>PhyOutput</code> is usually created by importing data using the <a href="/Laska.jl/dev/ref/core_ref#LaskaCore.importphy"><code>LaskaCore.importphy</code></a> function. It contains:</p><ul><li><p>All variables found in the file cluster_info.tsv accessible through <a href="/Laska.jl/dev/ref/core_ref#LaskaCore.info-Tuple{T} where T&lt;:AbstractCluster"><code>LaskaCore.info</code></a>.</p></li><li><p>Recording meta data accessible through <a href="/Laska.jl/dev/ref/core_ref#LaskaCore.getmeta"><code>LaskaCore.getmeta</code></a>.</p></li><li><p>A vector of triggertimes accessible through <a href="/Laska.jl/dev/ref/core_ref#LaskaCore.triggertimes-Tuple{T} where T&lt;:AbstractExperiment"><code>LaskaCore.triggertimes</code></a>.</p></li><li><p>Clusters/cells represented as <a href="/Laska.jl/dev/ref/core_ref#LaskaCore.Cluster"><code>LaskaCore.Cluster</code></a>.</p></li></ul><h3 id="cluster" tabindex="-1">Cluster <a class="header-anchor" href="#cluster" aria-label="Permalink to &quot;Cluster&quot;">​</a></h3><p>A <a href="/Laska.jl/dev/ref/core_ref#LaskaCore.Cluster"><code>LaskaCore.Cluster</code></a> represents a single cluster/cell and holds the ID of the cluster, its spiketimes and its corresponding row from the cluster_info.tsv file as a single-row DataFrame.</p><h4 id="spikevector" tabindex="-1">SpikeVector <a class="header-anchor" href="#spikevector" aria-label="Permalink to &quot;SpikeVector&quot;">​</a></h4><p>A <a href="/Laska.jl/dev/ref/core_ref#LaskaCore.SpikeVector"><code>LaskaCore.SpikeVector</code></a> is used for holding spiketimes in a <a href="/Laska.jl/dev/ref/core_ref#LaskaCore.Cluster"><code>LaskaCore.Cluster</code></a>. Its only difference from a &quot;normal&quot; <code>Vector{T}</code> is that it also holds the samplerate of its spiketimes which may be accessed with <a href="/Laska.jl/dev/ref/core_ref#LaskaCore.samplerate-Tuple{AbstractCluster}"><code>LaskaCore.samplerate</code></a>. This allows <code>Unitful.jl</code> units to automatically be converted to the samplerate of the spiketimes.</p><h2 id="relativespikes" tabindex="-1">RelativeSpikes <a class="header-anchor" href="#relativespikes" aria-label="Permalink to &quot;RelativeSpikes&quot;">​</a></h2><p>A <a href="/Laska.jl/dev/guide/types#RelativeSpikes"><code>RelativeSpikes</code></a> struct is similar to a <code>PhyOutput</code> in that it is meant to hold all <code>Cluster</code>s from a single experiment. Most of the difference lies in that it holds <a href="/Laska.jl/dev/guide/types#RelativeCluster"><code>RelativeCluster</code></a>s.</p><p><code>RelativeSpikes</code> structs are usually created with the <a href="/Laska.jl/dev/ref/core_ref#LaskaCore.relativespikes-Union{Tuple{Y}, Tuple{S}, Tuple{M}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PhyOutput{T, U, M, S}, Dict{String, V}, Y, Y}} where {T, U, V, M, S&lt;:(Vector{&lt;:Integer}), Y&lt;:Real}"><code>LaskaCore.relativespikes</code></a> function. For more information on this see the section <a href="/Laska.jl/dev/guide/relativespikes#Filter-spikes-around-triggers">Filter spikes around triggers</a>.</p><h3 id="relativecluster" tabindex="-1">RelativeCluster <a class="header-anchor" href="#relativecluster" aria-label="Permalink to &quot;RelativeCluster&quot;">​</a></h3><p>These only hold spiketimes around specified trigger events and each time is represented relative to the event that it &quot;belongs&quot; to. Instead of <code>SpikeVector</code>s spiketimes are held in <code>RelativeSpikeVector</code>s as described below.</p><h4 id="relativespikevector" tabindex="-1">RelativeSpikeVector <a class="header-anchor" href="#relativespikevector" aria-label="Permalink to &quot;RelativeSpikeVector&quot;">​</a></h4><p>A <a href="/Laska.jl/dev/ref/core_ref#LaskaCore.RelativeSpikeVector"><code>LaskaCore.RelativeSpikeVector</code></a> is analogous to a <code>Vector{Vector{T}}</code>, ie a vector of vectors. Each sub-vector holds the spikes surrounding one trigger event. Spiketimes are represented relative to the event rather than to recording start. A spike occurring 230ms before the event will have a time of -230ms, a spike occuring <em>at</em> the event 0ms and so on. Indexing into the events/spiketimes is done like so: <code>vec[i][j]</code> which will return the <code>j</code>:th spiketime of the <code>i</code>:th trigger event.</p>',17),i=[s];function l(c,d,n,p,h,u){return t(),a("div",null,i)}const v=e(o,[["render",l]]);export{k as __pageData,v as default};
